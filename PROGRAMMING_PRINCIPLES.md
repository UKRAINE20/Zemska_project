# Принципи програмування в проєкті ChessConsole

## 1. DRY (Don't Repeat Yourself — Не повторюй себе)
Принцип полягає в уникненні дублювання коду шляхом винесення спільної логіки в окремі модулі, класи або методи.

* **Клас `Direction` для лінійного руху**:
    Логіка перевірки "лінії видимості" (для тури, слона, ферзя) ідентична: потрібно йти по клітинках, поки не зустрінеш перешкоду. Замість того, щоб писати однакові цикли `for` у кожній фігурі, ця логіка винесена в клас `Direction`.
    * *Логіка:* `Direction.cs` (рядки 62-79) — метод `GetPossibleMoves`.
    * *Використання:* `Bishop.cs` (рядки 33-39), `Rook.cs` (рядки 33-39), `Queen.cs` (рядки 33-39).

* **Метод `OpenLineOfSight`**:
    Базова математика переміщення по сітці координат винесена в клас клітинки (`Cell`). Це дозволяє використовувати одну й ту ж логіку як для фігур, так і для інших перевірок на дошці.
    * *Файл:* `ChessBoard.cs` (рядки 63-77).

* **Рендеринг тексту**:
    Логіка малювання тексту (перетворення рядка в масив символів `CChar`) інкапсульована в одному методі, що використовується багаторазово.
    * *Файл:* `ConsoleGraphics.cs` (рядки 118-127) — метод `DrawText`.

---

## 2. KISS (Keep It Simple, Stupid — Роби це простіше)
Принцип закликає уникати зайвої складності, де це можливо.

* **Головний ігровий цикл**:
    Структура програми максимально проста і лінійна: `Draw` -> `SwapBuffers` -> `Update`. Немає зайвих потоків або складних систем подій, які не потрібні для консольної гри.
    * *Файл:* `Program.cs` (рядки 13-19).

* **Структура фігур**:
    Ієрархія класів пласка: `Piece` -> `SpecificPiece` (наприклад, `Pawn`). Немає зайвих проміжних рівнів абстракції (наприклад, `Entity` -> `Movable` -> `Unit`), що спрощує розуміння коду.
    * *Файл:* `Piece.cs` (рядок 6).
    * *Файл:* `Pawn.cs` (рядок 5).

---

## 3. SOLID
Набір з п'яти принципів об'єктно-орієнтованого програмування.

### SRP (Single Responsibility Principle — Принцип єдиної відповідальності)
Кожен клас повинен мати лише одну причину для зміни.

* **`ConsoleGraphics.cs`**:
    Цей клас відповідає **лише** за малювання символів у консолі (буферизацію). Він нічого не знає про правила шахів, фігури чи логіку гри. Якщо ми захочемо змінити правила ходу коня, цей файл не зміниться.
    * *Файл:* `ConsoleGraphics.cs` (весь файл).

* **`ChessBoard.cs`**:
    Відповідає за стан дошки та валідацію ходів. Він не займається введенням даних (це в `ChessGame`) або виведенням (це в `ConsoleGraphics`).
    * *Файл:* `ChessBoard.cs` (рядки 12-297).

### OCP (Open/Closed Principle — Принцип відкритості/закритості)
Програмні сутності повинні бути відкриті для розширення, але закриті для модифікації.

* **Додавання нових фігур**:
    Система спроєктована так, що для додавання нової фігури (наприклад, "Канцлер") потрібно створити новий клас, що наслідує `Piece`. Не потрібно змінювати логіку методу `TurnStart` або цикл перерахунку ходів у класі `ChessBoard`, оскільки вони працюють з абстракцією `Piece`.
    * *Абстракція:* `Piece.cs` (рядки 80-86).
    * *Поліморфний виклик:* `ChessBoard.cs` (рядки 249-252).

### LSP (Liskov Substitution Principle — Принцип підстановки Лісков)
Об'єкти повинні бути замінюваними екземплярами їхніх підтипів без порушення правильності роботи програми.

* **Колекція фігур**:
    Список `pieces` у класі `ChessBoard` зберігає об'єкти типу `Piece`. Ми можемо додати туди `King`, `Pawn` або `Rook`, і програма працюватиме коректно, викликаючи відповідні методи для кожного підтипу.
    * *Файл:* `ChessBoard.cs` (рядок 121: `List<Piece> pieces`).
    * *Приклад підстановки:* `ChessBoard.cs` (рядки 189-216).

---

## 4. YAGNI (You Aren't Gonna Need It — Тобі це не знадобиться)
Відмова від додавання функціональності, поки вона дійсно не стане потрібною.

* **Відсутність зайвих властивостей у `Piece`**:
    Клас `Piece` містить лише те, що потрібно для механіки шахів: колір (`Color`), чи рухалась фігура (`Moved`) та список ходів. У ньому немає полів на кшталт `Id`, `Name`, `Health` або `TexturePath`, які часто додають "на майбутнє", але які не потрібні для цієї консольної реалізації.
    * *Файл:* `Piece.cs` (рядки 13-33).

* **Проста реалізація `ConsoleGraphics`**:
    Графічний рушій реалізує лише те, що використовується: `Draw`, `DrawText`, `FillArea`. В ньому немає методів для малювання ліній, кіл або складної анімації, оскільки для шахів у консолі це зайве.
    * *Файл:* `ConsoleGraphics.cs` (рядки 81-197).
