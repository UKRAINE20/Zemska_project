# Принципи програмування в проєкті ChessConsole


## 1. DRY (Don't Repeat Yourself — Не повторюй себе)
Принцип полягає в уникненні дублювання коду шляхом винесення спільної логіки в окремі модулі або класи.

* **Клас `Direction` для лінійного руху**:
    Логіка перевірки "лінії видимості" (для тури, слона, ферзя) ідентична: рух по клітинках до перешкоди. Замість дублювання циклів `for` у кожній фігурі, ця логіка винесена в окремий клас.
    * *Логіка:*  [Direction.cs](./ChessConsole/Direction.cs#L50) (Метод `GetPossibleMoves`)
    * *Використання (Слон):* [Bishop.cs](./ChessConsole/Pieces/Bishop.cs)
    * *Використання (Тура):* [Rook.cs](./ChessConsole/Pieces/Rook.cs)

* **Метод `OpenLineOfSight`**:
    Базова математика переміщення по сітці координат та перевірка меж дошки винесена в клас клітинки (`Cell`).
    * *Реалізація:* [ChessBoard.cs](./ChessConsole/ChessBoard.cs#L62)

* **Рендеринг тексту**:
    Логіка перетворення рядка в масив кольорових символів інкапсульована в одному методі `DrawText` та `DrawTextTrasparent`, що використовується для всіх текстових написів.
    * *Реалізація:* [ConsoleGraphics.cs](./ChessConsole/ConsoleGraphics.cs#L131-160)

---

## 2. KISS (Keep It Simple, Stupid — Роби це простіше)
Принцип закликає уникати зайвої складності в архітектурі та логіці.

* **Головний ігровий цикл**:
    Структура програми максимально лінійна: Малювання -> Зміна буфера -> Оновлення логіки. Відсутні складні системи подій або зайва багатопотоковість.
    * *Реалізація:* [Program.cs](./ChessConsole/Program.cs#)

* **Ієрархія класів**:
    Використовується проста дворівнева ієрархія: абстрактний `Piece` та конкретні реалізації (`Pawn`, `King` тощо). Немає надлишкових шарів абстракції.
    * *Базовий клас:* [Piece.cs](./ChessConsole/Piece.cs#L8)
    * *Конкретна реалізація:* [Pawn.cs](./ChessConsole/Pieces/Pawn.cs#L5)

---

## 3. SOLID
Набір принципів для підтримки гнучкості та чистоти коду.

### SRP (Single Responsibility Principle — Принцип єдиної відповідальності)
Кожен клас має лише одну зону відповідальності.

* **`ConsoleGraphics.cs`**: Відповідає виключно за рендеринг та роботу з буфером консолі. Не містить логіки гри.
    * *Файл:* [ConsoleGraphics.cs](./ChessConsole/ConsoleGraphics.cs#L43)
* **`ChessBoard.cs`**: Відповідає за стан клітинок та валідацію ходів, але не за малювання чи введення.
    * *Файл:* [ChessBoard.cs](./ChessConsole/ChessBoard.cs#L12)

### OCP (Open/Closed Principle — Принцип відкритості/закритості)
Код відкритий для розширення, але закритий для змін.

* **Додавання фігур**: Щоб додати нову фігуру, ми створюємо новий клас, що наслідує `Piece`. Логіка перерахунку ходів у `ChessBoard` не потребує змін, оскільки вона працює з абстракцією.
    * *Абстрактний метод:* [Piece.cs](./ChessConsole/Piece.cs#L81)
    * *Поліморфний виклик:* [ChessBoard.cs](./ChessConsole/ChessBoard.cs#L158)

### LSP (Liskov Substitution Principle — Принцип підстановки Лісков)
Об'єкти підкласів можуть замінювати об'єкти базового класу.

* **Список фігур**: Клас `ChessBoard` оперує списком `List<Piece>`. Будь-яка фігура (Пішак, Король) коректно працює в цьому списку без необхідності перевірки типу в циклах оновлення.
    * *Колекція:* [ChessBoard.cs](./ChessConsole/ChessBoard.cs#L119)
    * *Додавання різних типів:* [ChessBoard.cs](./ChessConsole/ChessBoard.cs#L172)

---

## 4. YAGNI (You Aren't Gonna Need It — Тобі це не знадобиться)
Відмова від функціоналу, який не потрібен прямо зараз.

* **Мінімалістичний клас `Piece`**:
    Клас містить лише необхідні для логіки властивості (`Color`, `Moved`, `LegalMoves`). Відсутні поля "на майбутнє" (наприклад, `Id`, `TextureName`, `ScoreValue`), які не використовуються в поточній версії гри.
    * *Властивості:* [Piece.cs](./ChessConsole/Piece.cs#L13)

* **Консольна графіка**:
    Клас `ConsoleGraphics` реалізує тільки необхідні методи (`Draw`, `FillArea`). Не реалізовані складні графічні примітиви (кола, лінії), оскільки вони не потрібні для відображення шахів у консолі.
    * *Методи:* [ConsoleGraphics.cs](./ChessConsole/ConsoleGraphics.cs#L87)
